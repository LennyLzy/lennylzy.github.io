[{"title":"【置顶】博客导航","url":"/2025/09/25/%E7%BD%AE%E9%A1%B6-%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%88%AA/","content":"Java\n【面试】Java基础\n\nSpring微服务分布式云原生大数据AI与大模型数据库消息队列网络编程数据结构与算法博客"},{"title":"【面试】Java基础","url":"/2025/09/25/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/","content":"Java 面试题Java 基础Java 面向对象编程的特征在Java中，面向对象编程（Object-Oriented Programming，简称OOP）是一种程序设计范式，它基于“对象”的概念来设计程序。面向对象编程的特征主要包括：\n封装（Encapsulation）：\n\n封装是面向对象编程的核心概念之一。它通过将对象的数据（属性）和操作数据的方法（函数或过程）结合在一起，形成一个独立的单元。通过封装，可以隐藏对象的内部细节，只暴露必要的接口，从而降低系统的复杂度，提高系统的安全性。\n\n继承（Inheritance）：\n\n继承允许我们定义一个类（称为子类或派生类）来继承另一个类（称为父类或基类）的属性和方法。这样，子类可以复用父类的代码，并且可以扩展新的功能。继承是实现代码重用和构建层次结构的有效方式。\n\n多态（Polymorphism）：\n\n多态性允许我们使用统一的接口引用不同类的对象，这些对象可以在运行时表现出不同的行为。这是通过方法的重载（在同一类中方法名称相同但参数不同）和重写（在子类中提供特定于父类的方法实现）实现的。多态性提高了代码的灵活性和可扩展性。\n\n抽象（Abstraction）：\n\n抽象是简化复杂现实世界问题的过程。在Java中，抽象可以通过接口（Interface）和抽象类（AbstractClass）来实现。接口定义了一个类必须实现的方法列表，而不提供方法的具体实现；抽象类则可以包含方法和属性，但不能被实例化，除非它被扩展并实现了所有抽象方法。\n\n总结：\n\n\n\n特征\n实现\n作用\n\n\n\n封装\n类、访问修饰符(private&#x2F;protected&#x2F;public)\n隐藏实现细节，提供可控访问接口\n\n\n继承\nextends关键字、子类或派生类\n实现代码复用和层次化设计\n\n\n多态\n方法重写(override)、方法重载(overload)\n增强代码灵活性和扩展性\n\n\n抽象\n抽象类(abstract class)、接口(interface)\n定义规范，实现解耦\n\n\nJDK 和 JRE 有什么区别？\nJDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。\nJRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。\n\n具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。\n&#x3D;&#x3D; 和 equals 的区别是什么？&#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较。所以一般情况下 equals 比较的是值是否相等。\n两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？Java中hashCode()方法的主要作用是生成对象的哈希码值，用于在哈希表（如HashMap、HashSet等）中快速定位对象存储位置，从而提高数据检索效率。\nhashCode()的核心作用\n\n快速定位：在哈希表中，通过哈希码可以直接计算出对象在表中的存储位置（桶），避免遍历整个集合26。\n与equals()的契约：若两个对象equals()返回true，它们的hashCode()必须相同；反之不强制要求，但不同哈希码能减少冲突，提升性能25。\n一致性要求：同一对象在未修改状态下多次调用hashCode()应返回相同值。\n\n不对，两个对象的 hashCode()相同，equals()不一定 true。因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。\n哈希码的计算方法\n默认实现：\n\nObject类的默认hashCode()通常基于对象内存地址或特定算法（如HotSpot虚拟机的Marsaglia’s xor-shift算法）。\n可通过JVM参数（如-XX:hashCode=N）选择不同生成策略。\n\n\n重写规则：\n\n基础值：通常以非零质数（如17）初始化。\n\n字段处理：对关键字段（影响equals()的字段）依次计算哈希并合并，公式为：\nresult = 31 * result + (field == null ? 0 : field.hashCode());\n其中31因其奇素数特性可减少冲突。\n\n示例：\n@Override public int hashCode() &#123;     int result = 17; result = 31 * result + name.hashCode();     result = 31 * result + age; return result; &#125;`\n\n需确保与equals()逻辑一致。\n\n\n\n特殊类型处理：\n\n数组：对每个元素递归计算哈希并合并。\n基本类型：如Integer直接返回值，Long使用高低位异或。\nString：基于字符内容计算，相同字符串必同哈希。\n\n\n\n注意事项\n\n冲突容忍：允许不同对象哈希码相同（冲突），但过多冲突会降低性能。\n不可变性：若对象作为哈希表键，应确保哈希码相关字段不可变。\n\njava 中的 Math.round(-1.5) 等于多少？等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。\nString 属于基础的数据类型吗？String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。\n\n\n\n类型\n数据类型\n字节数\n位数\n最大值\n最小值\n\n\n\nbyte\n整型\n1\n8\n127（2^7-1）\n-128（-2^7）\n\n\nshort\n整型\n2\n16\n32767（2^15 - 1）\n-32768（-2^15）\n\n\nint\n整型\n4\n32\n2,147,483,647（2^31 - 1）\n-2,147,483,648（-2^31）\n\n\nlong\n整型\n8\n64\n9,223,372,036,854,775,807（2^63 -1）\n-9,223,372,036,854,775,808（-2^63）\n\n\nfloat\n浮点型\n4\n32\n±3.4E+38\n±3.4E+38\n\n\ndouble\n浮点型\n8\n64\n±1.7E+308\n±1.7E+308\n\n\nboolean\n布尔型\n1\n8\n\n\n\n\nchar\n字符型\n2\n16\n65535\n0\n\n\njava 中操作字符串都有哪些类？它们之间有什么区别？操作字符串的类有：String、StringBuffer、StringBuilder。String 和 StringBuffer、StringBuilder 的区别在于\n\nString 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象\n\nStringBuffer、StringBuilder 可以在原有对象的基础上进行操作，不会产生新对象，所以在经常改变字符串内容的情况下最好不要使用String。\n\n\nStringBuffer 和 StringBuilder 最大的区别在于\n\nStringBuffer 是线程安全的，而 StringBuilder 是非线程安全的\n\n但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用StringBuffer。\n\n\nString str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？不一样，因为内存的分配方式不一样。\nString str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；\n而 String str&#x3D;new String(“i”) 则会被分到堆内存中。\n如何将字符串反转？使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\nString 类的常用方法都有那些？indexOf()：返回指定字符的索引。charAt()：返回指定索引处的字符。replace()：字符串替换。trim()：去除字符串两端空白。split()：分割字符串，返回一个分割后的字符串数组。getBytes()：返回字符串的 byte 类型数组。length()：返回字符串长度。toLowerCase()：将字符串转成小写字母。toUpperCase()：将字符串转成大写字符。substring()：截取字符串。equals()：字符串比较。\n抽象类必须要有抽象方法吗？不需要，抽象类不一定非要有抽象方法。\n普通类不能包含抽象方法，抽象类可以包含抽象方法。抽象类不能直接实例化，普通类可以直接实例化。\n抽象类能使用 final 修饰吗？不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类\n接口和抽象类有什么区别？实现： 抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n构造函数： 抽象类可以有构造函数；接口不能有。\nmain 方法： 抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。\n实现数量： 类可以实现很多个接口；但是只能继承一个抽象类。\n访问修饰符： 接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\nIOJava I&#x2F;O流核心分类与区别\n字节流与字符流\n\n字节流：以字节为单位操作数据，核心抽象类为InputStream和OutputStream，适用于所有文件类型（如图片、视频）。典型实现包括FileInputStream&#x2F;FileOutputStream（文件读写）和BufferedInputStream&#x2F;BufferedOutputStream（缓冲优化性能）。\n字符流：以字符（Unicode）为单位操作数据，核心抽象类为Reader和Writer，适用于文本文件（如.txt、.csv）。典型实现包括FileReader&#x2F;FileWriter（文本读写）和BufferedReader&#x2F;BufferedWriter（缓冲优化+逐行读取）。\n区别：字节流直接处理二进制数据，字符流自动处理字符编码；字节流无缓冲区，字符流通过缓冲区提升性能。\n\n\n设计模式应用\n\n装饰器模式：动态扩展流功能，如为文件流添加缓冲：\nInputStream is = new BufferedInputStream(new FileInputStream(&quot;file.txt&quot;));\n\n适配器模式：InputStreamReader和OutputStreamWriter作为字节流与字符流的桥梁。\n\n\n\n\nNIO与传统I&#x2F;O（BIO）对比\nBIO（阻塞I&#x2F;O）：\n线程模型：1连接对应1线程，高并发时资源消耗大。\n数据读写：面向流（Stream），单向传输。\n\n\nNIO（非阻塞I&#x2F;O）：\n线程模型：基于多路复用器（Selector），单线程处理多连接。\n数据读写：面向缓冲区（Buffer），支持双向读写。核心组件包括Channel、Buffer、Selector。\n\n\n优势：非阻塞（线程无需等待数据就绪）、零拷贝（减少用户态与内核态数据拷贝）、适用于高并发场景（如Netty）。\n\n同步IO与异步IO\n同步IO：操作完成前阻塞程序执行（如FileInputStream读取大文件时线程阻塞）。\n异步IO：操作开始与结束分离，程序继续执行其他任务，完成后通过回调通知（如AsynchronousFileChannel的CompletionHandler）。\n\n常见IO模型\n阻塞IO：调用IO函数后线程阻塞，直到数据就绪。\n非阻塞IO：通过轮询检查数据是否就绪，避免线程阻塞但占用CPU。\nIO多路复用：通过select&#x2F;epoll系统调用监控多个连接，数据就绪后再发起read调用（如Java NIO的Selector）。\n异步IO（AIO）： 基于事件和回调机制，操作完成后由操作系统通知线程。\n\n缓冲区\n“Java I&#x2F;O流中缓冲区的作用是什么？为什么需要手动调用flush()？”\n“字符流和字节流在缓冲机制上有何区别？”\n\n核心作用：缓冲区通过减少频繁的磁盘I&#x2F;O操作提升性能（如BufferedInputStream默认8KB缓冲区）。\n字符流特殊性：BufferedWriter等字符流默认带缓冲区，需显式调用flush()强制写入数据，否则可能丢失。\n示例场景：\ntry (BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;log.txt&quot;))) &#123;     writer.write(&quot;数据&quot;); // 数据暂存缓冲区    writer.flush(); // 强制刷盘 &#125;\n\n序列化实现\n“如何实现Java对象的序列化？需要注意哪些问题？”\n“transient关键字在序列化中起什么作用？”\n\n回答要点：\n\n基本步骤：类实现Serializable接口，通过ObjectOutputStream写入对象流。\n\n关键点：\n\n序列化ID（serialVersionUID）用于版本控制，未显式定义时可能因类改动导致反序列化失败。\ntransient修饰的字段不会被序列化（如敏感信息）。\n\n\n示例代码：\npublic class User implements Serializable &#123;     private static final long serialVersionUID = 1L;     private String name;     private transient String password; // 不序列化 &#125;\n\n流关闭技巧面试提问方式：\n\n“处理Java I&#x2F;O流时，如何正确关闭资源？try-with-resources的优势是什么？”\n“多层流的关闭顺序有什么讲究？”\n\n回答要点：\n\n自动关闭：try-with-resources（Java 7+）自动调用close()，避免资源泄漏。\ntry(BufferedReader br = new FileReader(&quot;test.txt&quot;)) &#123;      String line;      while((line = br.readLine()) != null) &#123;          System.out.println(line);      &#125;  &#125; catch(IOException e) &#123;      System.err.println(&quot;读取文件出错: &quot; + e.getMessage());  &#125;  \n\n手动关闭顺序：从外到内依次关闭（如先关闭BufferedWriter，再关闭底层的FileWriter）\n\n错误示范：\nFileInputStream fis = new FileInputStream(&quot;file.txt&quot;); fis.read(); fis.close(); // 可能抛出IOException\n\n节点流与处理流面试提问方式：\n\n“解释节点流和处理流的区别，举例说明它们的典型应用场景。”\n“为什么需要包装流？BufferedReader属于哪种类型？”\n\n回答要点：\n\n节点流：直接操作数据源（如FileInputStream读取文件原始字节）。\n\n处理流：包装节点流增强功能（如BufferedReader提供逐行读取方法readLine()）。\n\n设计模式：处理流使用装饰器模式动态扩展功能（如加密、压缩流）。\n\n示例对比：\n// 节点流直接操作文件FileReader fr = new FileReader(&quot;text.txt&quot;); // 处理流包装节点流 BufferedReader br = new BufferedReader(fr); String line = br.readLine(); // 新增功能\n\n容器Java 容器都有哪些？Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：\n\nCollection\nList\nArrayList\nLinkedList\nVector\nStack\n\n\nSet\nHashSet\nLinkedHashSet\nTreeSet\n\n\n\n\nMap\nHashMap\nLinkedHashMap\n\n\nTreeMap\nConcurrentHashMap\nHashtable\n\n\n\nCollection 和 Collections 有什么区别？\nCollection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。\nCollections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法：Collections. sort(list)。\n\nList、Set、Map 之间的区别是什么？\n\n\n特性\nList\nSet\nMap\n\n\n\n元素重复性\n允许\n不允许\n键不允许，值允许\n\n\n顺序性\n保留插入顺序\n多数无序\n多数无序\n\n\n访问方式\n索引\n元素本身\n键\n\n\n典型实现\nArrayList\nHashSet\nHashMap\n\n\nHashMap 和 Hashtable 有什么区别？\n存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。\n线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。\n推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用ConcurrentHashMap 替代。\n\n如何决定使用 HashMap 还是 TreeMap？对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key集合进行有序的遍历，那 TreeMap 是更好的选择。\n说一下 HashMap 的实现原理？HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。\n说一下 HashSet 的实现原理？HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。\nArrayList 和 LinkedList 的区别是什么？\n数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。\n随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。\n增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。\n\n综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。\n如何实现数组和 List 之间的转换？Arrays.asList()注意事项\n\n‌返回固定大小列表‌该方法返回的是Arrays内部类ArrayList（非java.util.ArrayList），不支持add&#x2F;remove操作，否则抛出UnsupportedOperationException。但允许通过set()修改元素值。\n\n‌与原数组数据共享‌转换后的List直接引用原数组，修改List元素会同步影响原数组，反之亦然。多线程环境下需注意数据一致性。\n\n‌基本类型数组问题‌直接传入int[]等基本类型数组会被视为单个元素（List&lt;int[]&gt;），需使用包装类数组如Integer[]。\n\n\nList.toArray()注意事项\n\n‌类型安全写法‌推荐使用list.toArray(new 类型[0])，JDK6+会自动分配正确大小，避免类型转换。若数组长度大于list.size()，多余元素置为null。\n\n‌返回Object[]问题‌无参方法toArray()返回Object[]，需强制类型转换，可能存在ClassCastException风险。\n\n‌数据独立性‌转换后的数组是新对象，与原List无引用关系，修改数组不影响List。\n\n\n最佳实践\n\n‌数组转List‌\n\n需可变List时：new ArrayList&lt;&gt;(Arrays.asList(array))\n需只读List时：Collections.unmodifiableList(Arrays.asList(array))\n基本类型数组需先转为包装类数组。\n\n\n‌List转数组‌\n\n优先使用list.toArray(new String[0])（类型安全且高效）\n预分配数组大小时需注意null填充问题。\n\n\n‌线程安全场景‌若需在多线程中操作转换后的集合，应使用Collections.synchronizedList包装或深拷贝数据\n\n\nArrayList 和 Vector 的区别是什么？\n线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。\n性能：ArrayList 在性能方面要优于 Vector。\n扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加50%。\n\nArray 和 ArrayList 有何区别？\nArray 可以存储基本数据类型和对象，ArrayList 只能存储对象。\nArray 是指定固定大小的，而 ArrayList 大小是自动扩展的。\nArray 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。\n\n在 Queue 中 poll()和 remove()有什么区别？\n相同点：都是返回第一个元素，并在队列中删除返回的对象。\n不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。\n\nQueue&lt;String&gt; queue = new LinkedList&lt;String&gt;();queue. offer(&quot;string&quot;); // addSystem. out. println(queue. poll());System. out. println(queue. remove());System. out. println(queue. size());\n\n哪些集合类是线程安全的？Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。\n迭代器 Iterator 是什么？Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。\nIterator 怎么使用？有什么特点？Iterator 使用代码如下：\nList&lt;String&gt; list = new ArrayList&lt;&gt;();Iterator&lt;String&gt; it = list. iterator();while(it. hasNext())&#123;  String obj = it. next();  System. out. println(obj);&#125;\n\nIterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。\nIterator 和 ListIterator 有什么区别？\nIterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。\nIterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。\nListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。\n\n怎么确保一个集合不能被修改？可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java.lang. UnsupportedOperationException 异常。\n示例代码如下：\nList&lt;String&gt; list = new ArrayList&lt;&gt;();list. add(&quot;x&quot;);Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);clist. add(&quot;y&quot;); // 运行时此行报错System. out. println(list. size());\n\n异常Java中final、finally和finalize的区别Java中final、finally和finalize分别用于实现不可变性、异常处理资源清理和对象回收前的终结操作，三者功能完全不同。\n核心区别与用法详解\n\nfinal关键字。\n\n作用：声明不可变性，可修饰类、方法和变量。\n\n修饰类：禁止继承（如String类）。\n\n修饰方法：禁止子类重写（如Object类的getClass()方法）。\n\n修饰变量：初始化后不可修改（常量）。\n\n\n\n示例：\nfinal class ImmutableClass &#123;&#125;public final void print() &#123;&#125;final int MAX_VALUE = 100;\n\n\nfinally代码块\n\n作用：确保在try-catch结构中无论是否发生异常，均执行资源清理操作（如关闭文件、释放锁）。\n\n示例：\ntry &#123;  FileInputStream file = new FileInputStream(&quot;test.txt&quot;);&#125; catch (IOException e) &#123;  e.printStackTrace();&#125; finally &#123;  if (file != null) file.close(); // 确保资源关闭&#125;\n\n\nfinalize()方法。\n\n作用：在对象被垃圾回收前执行清理操作，但因其执行时间不可控且易导致性能问题，JDK9起已被标记为弃用，推荐使用try-with-resources或Cleaner API替代。\n\n示例：\n@Overrideprotected void finalize() throws Throwable &#123;// 不推荐使用&#125;\n\n\n\n对比总结\n\n功能差异：\n\nfinal：约束类、方法、变量的不可变性。\n\nfinally：保证资源清理代码必执行。\n\nfinalize()：对象回收前的终结方法（已弃用）。\n\n\n\n使用场景：\n\n需要常量或限制继承&#x2F;重写时用final；\n\n异常处理中管理资源用finally。\n\n避免使用finalize()，优先采用现代资源管理机制。\n\n\n\n\nthrow 和 throws 的区别？\nthrow：是真实抛出一个异常。\nthrows：是声明可能会抛出一个异常。\n\ntry-catch-finally 中哪个部分可以省略？try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者finally。\ntry-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。\n常见的异常类有哪些？\n运行时异常(RuntimeException)。通常由程序逻辑错误引起，编译器不强制要求处理，但应通过代码逻辑避免\n\nNullPointerException‌：当尝试访问空对象的属性或方法时抛出\n‌ArrayIndexOutOfBoundsException‌：数组下标越界时触发\n‌ClassCastException‌：类型强制转换失败时产生\n‌ArithmeticException‌：算术运算异常（如除零操作）\n‌IllegalArgumentException‌：方法接收到非法参数时抛出\n‌NumberFormatException‌：字符串转换为数字格式不匹配时引发\n‌IllegalStateException‌：对象状态不满足方法调用条件时抛出\n‌ArrayStoreException‌：向数组存入不兼容类型对象时触发\n‌IndexOutOfBoundsException‌：集合或字符串索引越界\n‌ConcurrentModificationException‌：并发修改集合时检测到冲突\n\n\n非运行时异常(又叫检查异常，Checked Exception)。必须显式捕获（try-catch）或声明抛出（throws），否则编译不通过。\n\nIOException‌：输入输出操作失败\n‌SQLException‌：数据库访问错误\n‌FileNotFoundException‌：文件不存在时抛出\n‌ClassNotFoundException‌：类加载失败\n‌InterruptedException‌：线程被中断\n‌NoSuchMethodException‌：反射调用不存在的方法\n‌CloneNotSupportedException‌：对象不支持克隆操作\n‌EOFException‌：读取文件时意外到达末尾\n\n\n错误(Error)。错误则代表严重系统问题，一般无法程序化处理。\n\nOutOfMemoryError‌：内存耗尽\n‌StackOverflowError‌：栈溢出（如无限递归）\n‌NoClassDefFoundError‌：类定义缺失\n\n\n\n多线程并发并行并行和并发有什么区别？\n并行：多个处理器或多核处理器同时处理多个任务。\n并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。\n\n如下图：\n\n\n并发 &#x3D; 两个队列和一台咖啡机。\n并行 &#x3D; 两个队列和两台咖啡机。\n线程与线程池线程和进程的区别？一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。\n守护线程是什么？守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java中垃圾回收线程就是特殊的守护线程。\n创建线程有哪几种方式？创建线程有三种方式：\n\n继承 Thread 重写 run 方法；\n实现 Runnable 接口；\n实现 Callable 接口。\n\n说一下 runnable 和 callable 有什么区别？runnable 没有返回值，callable 可以拿到有返回值\ncallable 可以看作是 runnable 的补充。\n线程有哪些状态？线程的状态：\n\nNEW 尚未启动\nRUNNABLE 正在执行中\nBLOCKED 阻塞的（被同步锁或者IO锁阻塞）\nWAITING 永久等待状态\nTIMED_WAITING 等待指定的时间重新被唤醒的状态\nTERMINATED 执行完成\n\nsleep() 和 wait() 有什么区别？\n类的不同：sleep() 来自 Thread，wait() 来自 Object。\n释放锁：sleep() 不释放锁；wait() 释放锁。\n用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()&#x2F;notifyAll()直接唤醒。\n\nnotify()和 notifyAll()有什么区别？notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。\nnotifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。\n而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。\n线程的 run() 和 start() 有什么区别？start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。\nrun() 可以重复调用，而 start() 只能调用一次。\n创建线程池有哪几种方式？线程池创建有七种方式，最核心的是最后一种：\n\nnew SingleThreadExecutor()：\n它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；\n\nnew CachedThreadPool()：\n它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；\n\nnew FixedThreadPool(int nThreads)：\n重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads；\n\nnew SingleThreadScheduledExecutor()：\n创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；\n\nnew ScheduledThreadPool(int corePoolSize)：\n和new SingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；\n\nnew WorkStealingPool(int parallelism)：\n这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；\n\nThreadPoolExecutor()：\n是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。\n\n\n线程池都有哪些状态？\nRUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。\nSHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。\nSTOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。\nTIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。\nTERMINATED：terminated()方法结束后，线程池的状态就会变成这个。\n\n线程池中 submit() 和 execute() 方法有什么区别？\nexecute()：只能执行 Runnable 类型的任务。\nsubmit()：可以执行 Runnable 和 Callable 类型的任务。\n\nCallable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。\n同步与锁在 Java 程序中怎么保证多线程的运行安全？\n方法一：使用安全类，比如 Java. util. concurrent 下的类。\n方法二：使用自动锁 synchronized。\n方法三：使用手动锁 Lock。\n\n手动锁 Java 示例代码如下：\nLock lock = new ReentrantLock();lock. lock();try &#123;    System. out. println(&quot;获得锁&quot;);&#125; catch (Exception e) &#123;    // TODO: handle exception&#125; finally &#123;    System. out. println(&quot;释放锁&quot;);    lock. unlock();&#125;\n\n多线程中 synchronized 锁升级的原理是什么？synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了synchronized 锁的升级。\n锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。\n什么是死锁？当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。\n怎么防止死锁？\n尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。\n尽量使用 Java. util. concurrent 并发类代替自己手写锁。\n尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。\n尽量减少同步的代码块。\n\nThreadLocal 是什么？有哪些使用场景？ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。\nThreadLocal 的经典使用场景是数据库连接和 session 管理等。\n说一下 synchronized 底层实现原理？synchronized 是由一对 monitorenter&#x2F;monitorexit 指令实现的，monitor 对象是同步的基本实现单元。\n在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。\nsynchronized 和 volatile 的区别是什么？\nvolatile 是变量修饰符；synchronized 是修饰类、方法、代码段。\nvolatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。\nvolatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\n\nsynchronized 和 Lock 有什么区别？\nsynchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。\nsynchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有unLock()去释放锁就会造成死锁。\n通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\n\nsynchronized 和 ReentrantLock 区别是什么？synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。\n主要区别如下：\n\nReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；\nReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；\nReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。\n\n说一下 atomic 的原理？atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。\n说一下Java中的AQSAbstractQueuedSynchronizer（AQS）是Java并发包中的核心同步框架，用于构建锁和同步器（如ReentrantLock、Semaphore等）底层实现。\n其核心设计围绕以下要素展开：\n\n‌同步状态（state）：通过volatile int变量表示资源状态（如锁的重入次数或信号量计数），提供getState()、setState()等原子操作方法。\n‌CLH队列‌：采用FIFO双向队列管理竞争资源的线程，失败线程会被封装为Node节点加入队列尾部，头节点表示当前持有资源的线程。\n‌模板方法模式‌：子类需实现tryAcquire（独占模式）或tryAcquireShared（共享模式）等钩子方法，定义资源获取与释放的具体逻辑。\n\n工作原理\n\n‌独占模式‌（如ReentrantLock）：线程通过CAS尝试修改state，成功则获取资源；失败则加入队列并阻塞（LockSupport.park），待前驱节点释放资源后唤醒后续节点。\n‌共享模式‌（如CountDownLatch）：允许多线程同时获取资源，通过tryAcquireShared返回剩余资源数，释放时唤醒后续共享节点。\n\n关键特性\n\n‌公平性与非公平性‌：通过队列实现公平锁（严格FIFO），非公平锁允许插队（减少线程切换开销）。\n‌CAS操作‌：使用compareAndSetState等原子操作保证线程安全，避免锁竞争带来的性能损耗。\n‌可重入性‌：支持同一线程多次获取锁（如ReentrantLock通过累加state实现）。\n\n典型应用\nAQS是JUC中多个同步组件的基础：\n\nReentrantLock：基于独占模式实现可重入锁。\nSemaphore：通过共享模式控制资源访问许可数。\nCountDownLatch：利用共享状态实现线程等待机制。\n\nAQS通过解耦同步状态管理与线程调度，大幅简化了自定义同步器的实现难度。\n除了锁以外还有什么同步工具？CountDownLatch（倒计时器）\n允许一个或多个线程等待其他线程完成操作。通过计数器实现，初始值为需要等待的事件数，线程调用countDown()递减计数器，调用await()阻塞直到计数器归零35。‌典型场景‌：主线程等待多个子任务完成后再继续执行。\nCyclicBarrier（循环屏障）\n与CountDownLatch类似，但支持重用。多个线程调用await()时会被阻塞，直到所有线程到达屏障点后继续执行，并可重置计数器用于下一轮同步35。‌典型场景‌：分阶段任务（如多轮游戏回合同步）。\nSemaphore（信号量）\n控制同时访问资源的线程数量，通过许可证（acquire()和release()）管理资源池。\n\n‌公平性‌：支持公平和非公平模式。\n‌扩展性‌：可用于实现连接池、限流等。\n\nPhaser（相位器）\n增强版的CyclicBarrier，支持动态调整参与的线程数，并分阶段（phase）同步。‌典型场景‌：复杂任务的多阶段协调（如批量处理分片数据）。\nStampedLock（戳记锁）\nJava 8引入的高性能锁，支持乐观读、悲观读和写锁，适用于读多写少场景。\n\n‌乐观读‌：无阻塞尝试读取，通过验证戳记（stamp）判断是否冲突。\n‌锁转换‌：支持读锁升级为写锁（需谨慎避免死锁）。\n\n原子类（Atomic包）\n通过CAS（Compare-And-Swap）实现无锁同步，如AtomicInteger、AtomicReference等，适用于计数器、状态标志等简单场景。\nExchanger（交换器）\n用于两个线程间交换数据，双方调用exchange()时会阻塞直到数据交换完成。‌典型场景‌：生产者-消费者模型的双向数据传输。\nReadWriteLock（读写锁）\nReentrantReadWriteLock实现读写分离，允许多个读线程并发访问，写线程独占资源。‌优化点‌：适合读多写少的场景（如缓存系统）。\n这些工具覆盖了线程协作、资源控制、无锁编程等需求，开发者可根据场景选择合适机制。\n关于协程Java 目前支持协程，主要通过 虚拟线程（Virtual Threads） 实现，这是 Java 19 及更高版本引入的轻量级线程机制，由 JVM调度，底层复用操作系统线程（载体线程），开发者可以像使用普通线程一样编写代码，但虚拟线程的创建和切换成本极低。\nJava 协程的实现方式\n\n‌Project Loom（虚拟线程）\n\nJava 19+ 原生支持，通过 Executors.newVirtualThreadPerTaskExecutor() 创建虚拟线程，适用于高并发场景1。\n\n示例代码：\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) &#123;     executor.submit(() -&gt; System.out.println(&quot;Hello, Virtual Thread!&quot;)); &#125;\n\n\n‌第三方库‌\n\n‌Quasar‌：通过字节码增强实现纤程（Fiber），但需额外依赖。\n‌Kotlin 协程‌：可在 Java 项目中通过 Kotlin 集成，但需混合编程。\n\n\n‌异步编程替代方案‌\n\nCompletableFuture 或响应式编程（如 Reactor）可模拟协程行为，但语法复杂度较高。\n\n\n\n协程与传统线程对比\n\n\n\n特性\n协程（虚拟线程）\n传统线程\n\n\n\n调度方式\n用户态（JVM 调度）\n内核态（OS 调度）\n\n\n切换开销\n极低（纳秒级）\n较高（微秒级）\n\n\n内存占用\n轻量（KB 级栈）\n较重（MB 级栈）\n\n\n适用场景\nIO 密集型、高并发\nCPU 密集型\n\n\n虚拟线程的推出标志着 Java 协程的正式落地，未来将成为高并发开发的主流选择。\n反射1. 什么是Java反射机制？反射机制允许程序在运行时动态获取类的信息（如类名、字段、方法、构造器等）并操作对象，而无需在编译时确定这些信息。核心功能包括运行时类加载、方法调用和字段访问，主要通过java.lang.reflect包实现。\n2. 反射的核心类有哪些？\nClass类：表示类的实体，如String.class。\nField类：表示类的成员变量，如getDeclaredField()。\nMethod类：表示类的方法，如invoke()。\nConstructor类：表示类的构造方法，如newInstance()。\n\n3. 如何获取Class对象的三种方式？\nClass.forName(&quot;全类名&quot;)：通过类路径加载（如Class.forName(&quot;java.lang.String&quot;)）。\n对象.getClass()：通过实例获取（如&quot;Hello&quot;.getClass()）。\n类名.class：直接通过类字面量获取（如String.class）。\n\n4. 如何通过反射创建对象？\n已过时方式：Class.newInstance()（要求无参构造且可访问）。\n推荐方式：通过Constructor.newInstance()，支持带参构造（如Constructor&lt;T&gt; constructor = clazz.getConstructor(String.class); constructor.newInstance(&quot;arg&quot;)）。\n\n5. 如何访问私有成员？调用setAccessible(true)方法突破权限限制：\nField privateField = clazz.getDeclaredField(&quot;fieldName&quot;); privateField.setAccessible(true); Object value = privateField.get(obj);`\n\n同理适用于私有方法（getDeclaredMethod() + invoke()）。\n6. 反射的性能问题及优化建议？\n性能问题：反射比直接调用慢，因涉及动态解析和安全检查。\n优化建议：\n缓存反射对象（如Class、Method实例）。\n避免频繁反射调用，必要时转为直接调用。\n使用MethodHandle（Java 7+）替代部分反射操作。\n\n\n\n7. 反射的实际应用场景？\n框架开发：如Spring的依赖注入、MyBatis的ORM映射。\n动态代理：如AOP实现。\n通用工具：如JSON序列化库（Gson、Jackson）。\n\n8. 反射的优缺点？\n优点：动态性高，支持运行时类加载和操作。\n缺点：性能开销大，绕过封装可能引发安全问题（如私有字段修改）。\n\n9. 如何通过反射获取泛型类型信息？通过ParameterizedType接口获取泛型实际类型：\nField field = clazz.getDeclaredField(&quot;genericList&quot;); Type type = field.getGenericType(); if (type instanceof ParameterizedType) &#123;     Type[] actualTypes = ((ParameterizedType) type).getActualTypeArguments(); &#125;\n\n适用于处理如List&lt;String&gt;等泛型字段。\n10. 如何处理反射中的常见异常？\nNoSuchMethodException：检查方法名和参数类型是否匹配。\nIllegalAccessException：确保已调用setAccessible(true)。\nInvocationTargetException：实际方法调用抛出的异常，需通过getCause()获取原始异常。\n\n对象拷贝深拷贝深拷贝是指在复制对象时，不仅复制对象本身，还递归地复制对象内部所有引用类型的字段所指向的对象。这样，新对象与原对象在内存中是完全独立的，修改新对象不会影响原对象。\n浅拷贝浅拷贝是指在复制对象时，只复制对象本身，对于对象内部的引用类型字段，只复制引用而不复制引用的对象。因此，新对象与原对象会共享这些引用类型字段指向的对象。\n拷贝实现方式在Java中，对象拷贝有多种方式，每种方式有其特定的使用场景和性能考虑。以下是几种常见的对象拷贝方法：\n1. 使用克隆（Cloneable 和 Object.clone()）Java中的Cloneable接口和Object.clone()方法提供了一种浅拷贝（shallow copy）机制。\n示例代码：\npublic class MyClass implements Cloneable &#123;      private int id; private String name;      // 构造函数、getter 和 setter    @Override      protected Object clone() throws CloneNotSupportedException &#123;          return super.clone();      &#125;  &#125;  \n\n使用方式：\nMyClass original = new MyClass();  original.setId(1);  original.setName(&quot;Example&quot;);  MyClass copy = (MyClass) original.clone();  \n\n注意： 使用clone()方法时，需要确保类实现了Cloneable接口，并且正确地覆盖了clone()方法。另外，对于包含复杂对象的情况，这种方式可能不适用，因为它只进行浅拷贝。\n2. 使用构造函数或拷贝构造函数通过创建一个新的对象，并使用现有的对象作为参数来初始化它，可以实现深拷贝。\n示例代码：\npublic class MyClass &#123;      private int id;      private String name;      // 构造函数、getter 和 setterpublic     MyClass(MyClass other) &#123;          this.id = other.id;          this.name = other.name;          // 需要确保这里是基本数据类型或不可变对象的拷贝，例如String的拷贝是安全的。      &#125;  &#125;  \n\n使用方式：\nMyClass original = new MyClass();  original.setId(1);  original.setName(&quot;Example&quot;);  MyClass copy = new MyClass(original);  \n\n3. 使用序列化（Serialization）和反序列化（Deserialization）序列化和反序列化可以用于深拷贝，但这种方法比较重量级，因为它涉及到对象的完全重建。适用于复杂对象的深拷贝。\n示例代码：\nimport java.io.*; public class MyClass implements Serializable &#123;  private int id;  private String name;  // 构造函数、getter 和 setter&#125;  \n\n使用方式：\nMyClass original = new MyClass();  original.setId(1);  original.setName(&quot;Example&quot;);  ByteArrayOutputStream baos = new ByteArrayOutputStream();  ObjectOutputStream oos = new ObjectOutputStream(baos);  oos.writeObject(original);  // 序列化原始对象到字节流中。  ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());  ObjectInputStream ois = new ObjectInputStream(bais);  // 从字节流中反序列化出新的对象。  MyClass copy = (MyClass) ois.readObject();  // 深拷贝完成。  \n\n4. 使用Apache Commons Lang库的SerializationUtils或BeanUtils（例如BeanUtils.copyProperties）Apache Commons Lang库提供了一些工具类来简化对象的深拷贝。例如，使用SerializationUtils或BeanUtils.copyProperties。\n使用SerializationUtils进行深拷贝的示例：\nimport org.apache.commons.lang3.SerializationUtils; import java.io.Serializable; public class MyClass implements Serializable &#123; /* 实现Serializable接口 */ &#125;\n\n使用方式：MyClass copy = SerializationUtils.clone(original); &#x2F;&#x2F; 注意这种方式实际上是使用了序列化和反序列化的方法。 &#x2F;&#x2F;但这种方式更简洁一些。\n在Java中，深拷贝和浅拷贝是对象复制时常用的两种策略，它们的主要区别在于复制对象时对引用类型字段的处理方式。\n代理怎么实现动态代理\nJDK动态代理：基于Java反射机制实现，要求目标类必须实现一个或多个接口。代理对象通过实现InvocationHandler接口，利用java.lang.reflect.Proxy类创建代理对象。代理对象仅代理接口中的方法调用。\n\nCGLIB动态代理：基于ASM框架实现，通过生成目标类的子类来代理方法。它不要求目标类必须实现接口，因此可以代理没有接口的类。CGLIB通过继承方式创建代理类，并重写目标类的方法。\n\n\n使用场景\nJDK动态代理：适用于目标对象已经实现了接口的情况。由于Java反射的机制，它在性能上可能不如CGLIB，但应用场景更为广泛，特别是在面向接口编程的场景中使用较多。\nCGLIB动态代理：适用于没有实现接口的类，或者需要对类的所有方法进行代理的情况。CGLIB通过字节码处理框架ASM生成新的类，因此在性能上通常优于JDK动态代理。\n\n性能差异\nJDK动态代理：在创建代理对象时开销较小，但由于使用反射机制，方法调用时的性能较好。在调用次数较少的情况下，JDK动态代理的效率高于CGLIB动态代理，但在大量调用时，JDK动态代理的效率略低于CGLIB。\nCGLIB动态代理：创建代理对象的速度较快，但由于需要生成子类并重写方法，方法调用时的性能略逊于JDK动态代理。\n\n泛型泛型是什么？Java泛型‌是一种在编程时定义函数、类或接口时不具体指定将要操作的数据类型的方法。通过使用泛型，可以编写出更加通用、灵活且类型安全的代码。\n泛型的本质是参数化类型，即所操作的数据类型被指定为一个参数（type parameter），这种参数可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法‌。泛型的优点\n\n类型安全‌：泛型可以在编译时进行类型检查，减少运行时错误，提高代码的可读性和可重用性‌。\n\n‌避免强制类型转换‌：使用泛型可以避免在运行时进行类型转换，减少因类型转换错误带来的安全隐患‌。\n\n提高性能‌：虽然泛型在编译时会被擦除，但使用泛型可以减少不必要的类型检查和转换，从而提高性能‌。\n\n\n泛型的具体应用\n‌泛型类‌：在类名后面使用尖括号（&lt;&gt;）声明泛型参数。例如：\npublic class Box&lt;T&gt; &#123;      private T value;      public T getValue() &#123; return value; &#125;      public void setValue(T value) &#123; this.value = value; &#125;  &#125;\n\n在这个例子中，Box中的是泛型参数的声明，表明这个类可以存储任意类型的数据‌。\n‌泛型方法‌：在方法的返回类型前使用尖括号（&lt;&gt;）声明泛型参数。例如：\npublic &lt;T&gt; T genericMethod(T t) &#123; return t; &#125;\n\n这个方法可以接受任意类型的参数并返回相同的类型‌。\n‌泛型接口‌：接口的参数也可以是泛型。例如：\npublic interface Pair&lt;K, V&gt; &#123; public K getKey(); public V getValue(); &#125;\n\n这个接口可以用于存储键值对‌。\n泛型的实现机制\nJava中的泛型是伪泛型，即在编译阶段会将泛型相关的信息擦除，不会保留到运行时。这意味着泛型的主要作用是在编译时进行类型检查和优化，而不是在运行时保留具体的类型信息‌。\nType类Type是Java 编程语言中所有类型的公共高级接口（官方解释），也就是Java中所有类型的“爹”，它并不是我们平常工作中经常使用的int、String、List、Map等数据类型，而是从Java语言角度来说，对基本类型、引用类型向上的抽象；\nType体系中类型的包括：\n\n原始类型(Type):不仅仅包含我们平常所指的类，还包括枚举、数组、注解等\n参数化类型(ParameterizedType):就是我们平常所用到的泛型List、Map&lt;K,V&gt;,Set,Class&lt;?&gt;\n数组类型(GenericArrayType):并不是我们工作中所使用的数组String[] 、byte[]，而是带有泛型的数组，即T[]\n变量(TypeVariable):比如 T a\n基本类型(Class):原始类型，每个类(貌似接口也有)都会有个Class对象\n\n我们重点看一下ParameterizedType ：\npublic interface ParameterizedType extends Type &#123;      // 获取&lt;&gt;中实际的类型参数，以Type数组形式返回      Type[] getActualTypeArguments();      // 获取&lt;&gt;前面的类型      Type getRawType();      // 如果这个类型是某个类型所属，则获取这个所有者的类型，否则返回null,比如Map.Entry&lt;Sting,String&gt;，会返回Map      Type getOwnerType();  &#125;  \n\n解释类型擦除（Type Erasure）的概念及其影响‌答案‌：类型擦除是泛型的‌编译时特性‌，编译器移除所有泛型类型信息，字节码中只保留原始类型（如List→List）。‌影响‌：\n运行时无法获取泛型类型参数（如new ArrayList&lt;String&gt;().getClass() == new ArrayList&lt;Integer&gt;().getClass()结果为true）\n泛型类不能直接继承Throwable（如class MyException&lt;T&gt; extends Exception非法）\n需通过桥方法保持多态性（如集合类的add(E e)方法）\n\n什么是PECS原则（Producer Extends, Consumer Super）？‌答案‌：处理泛型集合时的‌通配符使用准则‌：\n\nProducer Extends‌：数据生产者（读取）使用&lt;? extends T&gt;\n\n// 从集合读取Number类型数据void sum(List&lt;? extends Number&gt; nums) &#123;    double total = 0;    for (Number n : nums) total += n.doubleValue();&#125;\n\n\nConsumer Super‌：数据消费者（写入）使用&lt;? super T&gt;\n\n// 向集合添加Integer及其子类void fill(List&lt;? super Integer&gt; list) &#123;    list.add(10);    list.add(20);&#125;\n\n如何处理泛型中的类型擦除限制？‌常用技巧‌：\n\n类型令牌（Type Token）‌：通过Class保留类型信息\n public class TypeSafeMap &#123;\n  private Map&lt;Class&lt;?&gt;, Object&gt; map = new HashMap&lt;&gt;();\n  public &lt;T&gt; void put(Class&lt;T&gt; type, T value) &#123;\n      map.put(type, value);\n  &#125;\n  public &lt;T&gt; T get(Class&lt;T&gt; type) &#123;\n      return type.cast(map.get(type));\n  &#125;\n &#125;\n\n\n‌超类型令牌（Super Type Token）‌：利用匿名内部类捕获泛型类型\nType type = new TypeReference&lt;List&lt;String&gt;&gt;()&#123;&#125;.getType();\n\n‌框架解决方案‌：如Gson通过TypeToken处理泛型序列\n\n\n新特性1. Java 8的Lambda表达式是什么？写出一个典型示例‌答案‌：Lambda表达式是‌函数式编程‌的语法实现，本质是匿名函数。语法：(参数) -&gt; {表达式体}‌示例‌：\n// 传统匿名内部类Runnable r1 = new Runnable() &#123;@Overridepublic void run() &#123;System.out.println(&quot;Hello&quot;);&#125;&#125;;// Lambda等效实现 ✅Runnable r2 = () -&gt; System.out.println(&quot;Hello&quot;);\n\n‌关键点‌：\n类型自动推断（可省略参数类型）\n单行表达式可省略&#123;&#125;和return\n必须匹配函数式接口（如Runnable）\n\n2. 什么是函数式接口？JDK提供了哪些核心函数式接口？‌答案‌：函数式接口是有且仅有一个‌抽象方法‌的接口（可含默认方法）。需用@FunctionalInterface注解标记。四大核心接口‌：\n\n\n\n接口\n方法签名\n典型用途\n\n\n\nSupplier&lt;T&gt;\nT get()\n数据提供（工厂模式）\n\n\nConsumer&lt;T&gt;\nvoid accept(T t)\n数据消费（如forEach）\n\n\nFunction&lt;T,R&gt;\nR apply(T t)\n数据转换（如map操作）\n\n\nPredicate&lt;T&gt;\nboolean test(T t)\n条件判断（如filter操作）\n\n\n‌示例‌：\nPredicate&lt;String&gt; isEmpty = s -&gt; s.isEmpty();System.out.println(isEmpty.test(&quot;&quot;));  // true\n\n3. Stream API的核心操作分哪两类？各举3个方法‌答案‌：‌中间操作（惰性求值）‌：\nfilter(Predicate)：过滤元素\nmap(Function)：元素转换\nsorted()：元素排序\n\n‌终结操作（触发计算）‌：\ncollect(Collector)：聚合为集合\nforEach(Consumer)：遍历元素\nreduce()：归约操作\n\n‌典型流程‌：\nList&lt;Integer&gt; squares = numbers.stream().filter(n -&gt; n % 2 == 0)       // 中间操作.map(n -&gt; n * n)               // 中间操作.collect(Collectors.toList()); // 终结操作\n\n4. Optional类解决了什么问题？举例说明主要方法‌答案‌：解决NullPointerException问题，强制显式处理null。‌核心方法‌：\nOptional&lt;String&gt; opt = Optional.ofNullable(getNullableString());// 避免if-null检查 ✅String value = opt.orElse(&quot;default&quot;);// 链式安全操作opt.map(String::toUpperCase).ifPresent(System.out::println);\n\n5. Java 9模块化系统（JPMS）的目标是什么？写出module-info.java示例‌答案‌：目标：‌强封装性‌和‌可靠配置‌。解决JAR地狱与类路径问题。‌示例‌：\n// module-info.javamodule com.myapp &#123;requires java.base;       // 隐式依赖requires java.sql;        // 显式声明依赖requires transitive lib.utils; // 传递依赖    exports com.myapp.api;    // 导出包    opens com.myapp.internal; // 反射开放包&#125;\n\n6. Java 10的局部变量类型推断（var）有什么限制？‌答案‌：‌可用场景‌：\n局部变量初始化：var list = new ArrayList&lt;String&gt;()\n增强for循环：for (var item : items)\n\n‌禁止场景‌：\nvar x;                      //  ❌ 未初始化var nullVal = null;         //  ❌ 无法推断类型public var name = &quot;Java&quot;;   //  ❌ 不能用于字段var runnable = () -&gt; &#123;&#125;;    // ❌ 不能用于Lambda\n\n7. Java 14的switch表达式有何改进？对比新旧写法‌答案‌：‌传统switch的问题‌：\n冗长的break\n容易遗漏default\n只能作为语句\n\n‌新特性‌：\n// 传统写法  ❌String result;switch (day) &#123;case MONDAY, FRIDAY:result = &quot;Busy&quot;;break;default:result = &quot;Normal&quot;;&#125;// Switch表达式 ✅String result = switch (day) &#123;case MONDAY, FRIDAY -&gt; &quot;Busy&quot;;case TUESDAY         -&gt; &quot;Meeting&quot;;default              -&gt; &#123;System.out.println(&quot;Other day&quot;);yield &quot;Normal&quot;;  // 代码块用yield返回&#125;&#125;;\n\n8. Java 15的文本块（Text Blocks）如何解决多行字符串问题？‌答案‌：使用三重引号”””定义跨行字符串，自动处理缩进和换行。‌示例‌：\n// 旧方式（混乱）String html = &quot;&lt;html&gt;\\n&quot; +&quot;  &lt;body&gt;\\n&quot; +&quot;    &lt;p&gt;Hello&lt;/p&gt;\\n&quot; +&quot;  &lt;/body&gt;\\n&quot; +&quot;&lt;/html&gt;&quot;;// 文本块写法 ✅String html = &quot;&quot;&quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello, %s&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;.formatted(user);\n\n‌特性‌：\n自动删除行尾空白\n保留行内缩进\n支持格式化方法\n\n9. Java 16的Record类解决了什么问题？写出示例‌答案‌：简化‌数据传输对象（DTO）‌ 的声明，自动生成equals()、hashCode()等方法。‌示例‌：\n// 传统POJO（冗长）public class Person &#123;private final String name;private final int age;// 构造/getter/equals/hashCode/toString...&#125;// Record替代方案 ✅public record Person(String name, int age) &#123; &#125;// 自动包含：// 全参构造 + name()/age()访问器 + equals/hashCode/toString\n\n10. Java 17的密封类（Sealed Classes）如何控制继承？‌答案‌：限制类&#x2F;接口只能被指定的子类继承。‌语法‌：\npublic sealed abstract class Shapepermits Circle, Rectangle, Triangle &#123; &#125; // 明确许可子类// 子类必须为以下之一：public final class Circle extends Shape &#123; &#125;   // 禁止再继承public non-sealed class Rectangle extends Shape &#123; &#125; // 开放继承public sealed class Triangle extends Shape permits Equilateral &#123; &#125; // 继续密封\n\n‌设计意义‌：\n\n增强领域建模安全性\n支持模式匹配的穷尽检查\n替代final的灵活控制\n\n","categories":["面试"],"tags":["Java"]}]